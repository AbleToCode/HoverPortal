# HoverPortal - 技术实施文档 (Technical Implementation Document)

## 1. 技术架构概览 (Architecture Overview)

本项目将基于 **Microsoft .NET 8 (或 .NET 6+)** 平台，采用 **C#** 语言结合 **WPF (Windows Presentation Foundation)** 框架进行开发。选择 WPF 是因为它在 Windows 平台上拥有成熟的图形渲染能力、强大的动画系统以及对底层 Win32 API 的良好互操作性，能够满足“丝滑动画”和“深度系统集成”的需求。

### 1.1 核心技术栈 (Tech Stack)
*   **开发语言**: C# 10.0+
*   **UI 框架**: WPF (.NET Core/5+)
*   **架构模式**: MVVM (Model-View-ViewModel) - 推荐使用 CommunityToolkit.Mvvm
*   **系统交互**: P/Invoke (User32.dll, Shell32.dll, Shlwapi.dll)
*   **UI 库/特效**: 
    *   **HandyControl** 或 **WPF UI** (用于现代化控件)
    *   **PInvoke.User32** (用于底层窗口管理)
    *   **Composition API** (可选，用于高性能模糊/亚克力效果)

## 2. 模块设计 (Module Design)

系统主要分为三个核心模块：**桌面钩子与侦测模块**、**悬浮窗 UI 渲染模块**、**文件系统与交互模块**。

### 2.1 桌面侦测模块 (Desktop Hook & Detection)
这是实现 FR-01 (悬停侦测) 的核心技术难点。
*   **目标**: 实时获取鼠标在桌面上的位置，并判断鼠标是否停留在某个“文件夹图标”上。
*   **实现方案**:
    1.  **句柄获取**: 通过 `FindWindow` 查找桌面窗口句柄（通常是 `Progman` 或 `WorkerW` 下的 `SHELLDLL_DefView` -> `SysListView32`）。
    2.  **跨进程通讯 (IPC)**: 桌面图标实际上是 ListView 的 Item。由于桌面属于 Explorer 进程，需要使用 `VirtualAllocEx`, `WriteProcessMemory`, `SendMessage (LVM_GETITEMRECT)`, `ReadProcessMemory` 这一套跨进程内存操作流程来获取每个图标的矩形区域 (Rect) 和对应的 Item 索引。
    3.  **鼠标轮询/钩子**: 使用全局鼠标钩子 (`SetWindowsHookEx` with `WH_MOUSE_LL`) 或简单的定时器轮询 (`GetCursorPos`) 来检测鼠标是否进入了某个图标的 Rect 区域。
*   **性能优化**: 缓存图标位置数据。只在收到 `WM_SETTINGCHANGE` 或桌面刷新事件时重新扫描位置，避免每帧读取内存。

### 2.2 视觉与动画模块 (Visual & Animation)
实现 FR-02 (流体动画) 和 FR-03 (视觉呈现)。
*   **窗口管理**:
    *   主悬浮窗应为透明无边框窗口 (`WindowStyle="None"`, `AllowsTransparency="True"`).
    *   **置顶策略**: 窗口需置于桌面图标之上，但尽量不遮挡其他普通应用窗口（可通过父窗口绑定或 Z-Order 管理）。
*   **动画实现**:
    *   使用 WPF 的 `Storyboard` 和 `DoubleAnimationUsingKeyFrames` 实现基础动画。
    *   **物理效果**: 为了达到“丝滑”和“弹簧”效果，建议引入物理动画库（如自定义基于弹簧阻尼公式的各类 Animation EasingFunction）。
*   **模糊背景**: 使用 `SetWindowCompositionAttribute` (由于是未公开 API，需谨慎) 或 Windows 11 官方的 `DwmSetWindowAttribute` (DWMWA_SYSTEMBACKDROP_TYPE) 来启用 Mica/Acrylic 效果。

### 2.3 文件与交互模块 (FileSystem & Interaction)
实现 FR-04 至 FR-07。
*   **文件读取**: 使用 `System.IO` 异步读取目标文件夹内容。
*   **图标与缩略图**:
    *   **Win32 API**: `SHGetFileInfo` 获取系统关联图标。
    *   **IShellItemImageFactory**: 获取高质量缩略图（针对图片/视频）。
*   **拖拽支持 (Drag & Drop)**:
    *   实现 WPF 的 `IDropTarget` 接口，处理文件拖入操作。
    *   使用 `DoDragDrop` 处理文件从悬浮窗拖出到外部的操作。

## 3. 关键数据流 (Key Data Flow)

1.  **初始化**: 应用启动 -> 获取桌面 ListView 句柄 -> 扫描所有图标位置与名称 -> 建立 `Map<Rect, FilePath>` 缓存。
2.  **侦测循环**: 鼠标移动 -> 坐标命中某个 Rect -> 启动计时器 (300ms)。
3.  **触发预览**: 计时器结束仍命中 -> 获取 `FilePath` -> 读取子文件列表 -> 实例化 ViewModel -> 播放展开动画 (Window Show)。
4.  **交互**: 用户点击文件 -> `Process.Start(file)` -> 动画收起。
5.  **结束预览**: 鼠标离开悬浮窗且离开原图标区域 -> 播放收缩动画 -> Window Hide。

## 4. 关键 API 列表 (Critical APIs)

*   `User32.dll`:
    *   `FindWindow`, `FindWindowEx`: 定位桌面窗口。
    *   `GetWindowThreadProcessId`: 获取 Explorer 进程 ID。
    *   `GetCursorPos`: 鼠标位置。
*   `Kernel32.dll`:
    *   `OpenProcess`: 打开 Explorer 进程权限。
    *   `VirtualAllocEx`, `VirtualFreeEx`: 注入内存。
    *   `ReadProcessMemory`, `WriteProcessMemory`: 读写内存以发送 LVM 指令。
*   `Shell32.dll`:
    *   `SHGetFileInfo`: 获取文件图标/类型。

## 5. 风险评估与应对 (Risk & Mitigation)
*   **风险**: 桌面壁纸引擎（如 Wallpaper Engine）可能会覆盖在标准桌面 ListView 之上，导致无法点击或识别。
    *   *应对*: 检测常见壁纸软件，尝试提升悬浮窗 Z-Order，或提供“兼容模式”手动指定层级。
*   **风险**: Windows 更新可能修改桌面窗口结构 (`WorkerW` 机制变化)。
    *   *应对*: 编写健壮的窗口查找逻辑，遍历所有可能的父类组合。
